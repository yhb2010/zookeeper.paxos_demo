当客户端和服务器之间的网络连接断开时，zookeeper客户端会自动进行反复的重连，直到最终成功连接上zookeeper集群中的一台机器，在这种
情况下，再次连接上服务器的客户端有可能处于以下两种状态之一：
	connected：如果在会话超时时间内重新连接上了zookeeper集群中的任意一台，那么被视为重连成功。
	expired：如果是在会话超时时间以外重连上，那么服务器其实已经对该会话进行了会话清理操作，因此再次连接上的会话将被视为非法会话。

在zookeeper中，客户端与服务端之间维持的是一个长连接，在sessionTimeout时间内，服务端会不断的检测该客户端是否还处于正常连接，服务端
会将客户端的每次操作视为一次有效的心跳检测来反复的进行会话激活。因此，在正常情况下，客户端会话是一直有效的，然而当客户端与服务端断开
连接后，用户在客户端可能主要会看到两种异常：connection_loss和session_expired，那么该如何正确处理它们呢？

连接断开connection_loss：
	有时因为网络闪断导致客户端与服务器断开连接，或是因为客户端当前连接的服务器出现问题导致连接断开，我么称“客户端与服务器断开连接”
	现象，即connection_loss。在这种情况下，zookeeper客户端会自动从地址列表中重新获取新的地址并尝试进行重新连接，直到最终成功连接
	上服务器。
	举个例子：某应用在使用zookeeper客户端进行setData操作时，正好出现了connection_loss现象，那么客户端会记录接收到事件：
	none-disconnected通知，同时会抛出异常ConnectionLossException。这时，我们的应用需要做的事情是捕获异常，然后等待zookeeper
	的客户端自动完成重连，一旦客户端成功连上一台zookeeper机器后，那么客户端就会收到事件none-syncconnnected通知，之后就可以重试
	刚才的setData操作。

会话失效session_expired
	通常发生在connection_loss期间，客户端和服务器连接断开后，由于重连期间耗时过长，超过了会话超时时间限制后还没有成功连接上服务器，
	那么服务器认为这个会话已经结束了，就会开始进行会话清理，但是另一方面，该客户端本身不知道会话已经失效了，并且其客户端状态还是
	disconnected。之后，如果客户端重新连接上了服务器，服务器会告知客户端会话已经失效，在这时，用户就需要重新实例化一个zookeeper
	对象，并看应用的复杂程度，重新恢复临时数据。

会话转移session_moved
	是指客户端会话从一台服务器转移到另一台服务器上，假设客户端和服务器s1之间的连接断开后，如果通过尝试重连后，成功连接上了新的服务器
	s2并且延续了有效会话，那么就可以说会话从s1转移到了s2上。